<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<title>Adaptive Equalizer</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1"></script>
<style>
  body { font-family: Arial, system-ui; max-width: 1100px; margin: 24px auto; padding: 0 12px; }
  .row { display:flex; gap:20px; margin:12px 0; flex-wrap:wrap; align-items:center; }
  label { font-size:12px; display:block; opacity:.85; }
  input[type=range]{ width:240px; }
  img { max-width:100%; border-radius:6px; display:block; }
  button{padding:8px 14px; cursor:pointer;}
  button[disabled]{ opacity:.6; cursor:not-allowed;}
  #msg{ color:#b00; margin:8px 0; min-height:1.2em; }
  .val { min-width: 42px; display:inline-block; text-align:right; }
  #progressWrap { display:none; align-items:center; gap:10px; }
  .spinner { width:16px; height:16px; border:2px solid #ccc; border-top-color:#333; border-radius:50%; animation:spin .8s linear infinite;}
  @keyframes spin { to{ transform:rotate(360deg)} }

  /* Modulation section */
  #modWrap{ border:1px solid #e5e5e5; border-radius:10px; padding:12px; }
  #curveArea{ display:flex; flex-direction:column; align-items:center; }
  #curveCanvas{ width: 900px; height: 240px; }
  /* Sliders aligned under curve points */
  #slidersRow{ display:flex; justify-content:space-between; width:900px; margin-top:14px; }
  .knobCol{ display:flex; flex-direction:column; align-items:center; user-select:none; }
  .knobCol input[type=range]{
    writing-mode: bt-lr; -webkit-appearance: slider-vertical;
    height: 150px; width: 28px;
  }
  .knobLabel{ font-size:11px; margin-top:6px; }

  /* Image grids + overlays */
  .imgGrid{ display:grid; grid-template-columns: repeat(3, 1fr); gap:16px; }
  .imgCard{ position:relative; border:1px solid #e5e5e5; border-radius:10px; padding:10px; }
  .imgTitle{ display:flex; align-items:center; gap:8px; margin-bottom:8px; }
  .overlayBox{
    position:absolute; top:10px; right:10px;
    background:rgba(0,0,0,0.6); color:#fff; padding:6px 8px;
    font-size:12px; border-radius:6px; max-width:45%; line-height:1.25;
    display:none;
  }
</style>
</head>
<body>
<h2>Adaptive Equalizer</h2>

<div class="row">
  <div>
    <label>Upload image</label>
    <input type="file" id="fileInput" accept="image/*" onchange="preview()"/>
  </div>
  <div>
    <label>band_sign</label>
    <select id="band_sign">
      <option value="dog" selected>dog</option>
      <option value="literal">literal</option>
    </select>
  </div>
  <label><input type="checkbox" id="preserve_mean" checked/> preserve mean</label>
</div>

<div class="row">
  <div>
    <label>alpha: <span id="alpha_val" class="val">1.00</span></label>
    <input type="range" id="alpha" min="0" max="3" step="0.05" value="1" oninput="sync('alpha')"/>
  </div>
  <div>
    <label>gamma: <span id="gamma_val" class="val">1.20</span></label>
    <input type="range" id="gamma" min="0.5" max="3" step="0.05" value="1.2" oninput="sync('gamma')"/>
  </div>
</div>

<div class="row">
  <div>
    <label>sigma_perc: <span id="sigma_val" class="val">0.33</span></label>
    <input type="range" id="sigma_perc" min="0.05" max="0.8" step="0.01" value="0.33" oninput="sync('sigma_perc')"/>
  </div>
  <div>
    <label>max_kernel (odd ≥3): <span id="mk_val" class="val">63</span></label>
    <input type="range" id="max_kernel" min="3" max="127" step="2" value="63" oninput="sync('max_kernel')"/>
  </div>
</div>

<!-- Modulation controls -->
<div id="modWrap">
  <div class="row" style="justify-content:space-between; align-items:center;">
    <strong>Band Modulation</strong>
    <div>
      <label>N knobs (3..10)</label>
      <input type="number" id="n_controls" min="3" max="10" step="1" value="5" style="width:64px;"/>
      <button onclick="applyKnobs()">Apply</button>
    </div>
  </div>

  <div id="curveArea">
    <canvas id="curveCanvas" width="900" height="240"></canvas>
    <div id="slidersRow"><!-- sliders inserted dynamically --></div>
  </div>
</div>

<div class="row">
  <button id="processBtn" onclick="process()">Process</button>
  <a id="downloadLinkEq" style="display:none;margin-left:8px;">Download Equalized</a>
  <a id="downloadLinkMod" style="display:none;margin-left:8px;">Download Modulated</a>
  <div id="progressWrap"><div class="spinner"></div><span id="progressText">Processing…</span></div>
</div>

<div id="msg"></div>

<!-- Results grid -->
<div class="imgGrid">
  <div class="imgCard">
    <div class="imgTitle">
      <strong>Original</strong>
      <label><input type="checkbox" id="overlayOrig" checked/> overlay parameters</label>
    </div>
    <div class="overlayBox" id="overlayBoxOrig"></div>
    <img id="imgOriginal" alt="Original"/>
  </div>

  <div class="imgCard">
    <div class="imgTitle">
      <strong>Equalized (no modulation)</strong>
      <label><input type="checkbox" id="overlayEq" checked/> overlay parameters</label>
    </div>
    <div class="overlayBox" id="overlayBoxEq"></div>
    <img id="imgEqualized" alt="Equalized"/>
  </div>

  <div class="imgCard">
    <div class="imgTitle">
      <strong>Modulated</strong>
      <label><input type="checkbox" id="overlayMod" checked/> overlay parameters</label>
    </div>
    <div class="overlayBox" id="overlayBoxMod"></div>
    <img id="imgModulated" alt="Modulated"/>
  </div>
</div>

<script>
function apiUrl(p){ return new URL(p, window.location.href).toString(); }
function setMsg(t){ document.getElementById('msg').textContent = t || ''; }
function sync(id){
  const v = document.getElementById(id).value;
  const span = document.getElementById(id==='sigma_perc' ? 'sigma_val' : id==='max_kernel' ? 'mk_val' : id + '_val');
  if (span) span.textContent = (id==='max_kernel') ? v : (+v).toFixed(2);
}
function preview(){
  setMsg('');
  const f=document.getElementById("fileInput").files[0];
  if(!f) return;
  const url=URL.createObjectURL(f);
  document.getElementById("imgOriginal").src = url; // quick preview for original
}

/* ---------- Modulation knobs + curve (Chart.js) ---------- */
let gains = [];     // N control points [0..4]
let chart = null;
let kernels = [];   // kernel sizes from server for tick labels
let nBands = 0;     // number of full bands; before processing we use gains.length

// plugin to draw y=1 horizontal line
const unityLine = {
  id: 'unityLine',
  afterDraw(chart, args, opts) {
    const yScale = chart.scales.y;
    const ctx = chart.ctx;
    const y = yScale.getPixelForValue(1);
    ctx.save();
    ctx.strokeStyle = '#888';
    ctx.setLineDash([5,4]);
    ctx.beginPath();
    ctx.moveTo(chart.chartArea.left, y);
    ctx.lineTo(chart.chartArea.right, y);
    ctx.stroke();
    ctx.restore();
  }
};

function applyKnobs(){
  const N = Math.max(3, Math.min(10, parseInt(document.getElementById('n_controls').value||5,10)));
  gains = Array(N).fill(1.0);
  renderSliders();
  renderChart();
  updateChartData();
}

function renderSliders(){
  const row = document.getElementById('slidersRow');
  row.innerHTML = '';
  gains.forEach((v,i)=>{
    const col = document.createElement('div');
    col.className = 'knobCol';

    const slider = document.createElement('input');
    slider.type = 'range';
    slider.min = '0'; slider.max = '4'; slider.step = '0.05';
    slider.value = String(v);
    slider.oninput = (e)=>{
      let val = parseFloat(e.target.value);
      // snap-to-1 when close
      if (Math.abs(val - 1.0) < 0.05) val = 1.0;
      gains[i] = val;
      e.target.value = String(val);
      label.textContent = `b${i+1}: ${gains[i].toFixed(2)}`;
      updateChartData();
    };

    const label = document.createElement('div');
    label.className = 'knobLabel';
    label.textContent = `b${i+1}: ${v.toFixed(2)}`;

    col.appendChild(slider);
    col.appendChild(label);
    row.appendChild(col);
  });
}

/* ----- Curve helpers with provisional bands before processing ----- */
function makeInterpolatedCurve(){
  const nb = nBands || gains.length;               // use N knobs until we know full band count
  if (!nb || !gains.length) return [];
  const xCtrl = gains.length === 1 ? [0] : linspace(0, nb-1, gains.length);
  const xs = Array.from({length: nb}, (_,i)=> i);
  const ys = interp1(xCtrl, gains, xs);
  return xs.map((x,i)=> ({x, y: ys[i]}));
}

function controlDatasetPoints(){
  const nb = nBands || gains.length;
  if (!nb || !gains.length) return [];
  const xCtrl = gains.length === 1 ? [0] : linspace(0, nb-1, gains.length);
  return xCtrl.map((x,i)=> ({x, y: gains[i]}));
}

function renderChart(){
  const ctx = document.getElementById('curveCanvas').getContext('2d');
  if (chart){ chart.destroy(); }
  const nb = nBands || gains.length;                // provisional count
  chart = new Chart(ctx, {
    type: 'line',
    data: {
      datasets: [
        { label:'Interpolated', data: makeInterpolatedCurve(), borderWidth:2, pointRadius:0, fill:false, tension:0.0 },
        { label:'Controls',     data: controlDatasetPoints(),  borderWidth:2, pointRadius:3, fill:false, tension:0.0 }
      ]
    },
    plugins: [unityLine],
    options: {
      animation: false,
      responsive: false,
      parsing: false,
      scales: {
        x: {
          type: 'linear',
          min: 0,
          max: Math.max(0, nb-1),
          ticks: {
            callback: (val) => {
              const idx = Math.round(val);
              if (idx < 0) return '';
              // If we have kernel sizes from the server, show them; otherwise show control indices (1..N)
              if (kernels && kernels.length && idx < kernels.length) {
                if (idx % 2 === 1) return '';  // skip every other to reduce clutter
                return `${kernels[idx]}×${kernels[idx]}`;
              } else {
                return (idx % 1 === 0) ? `b${idx+1}` : '';
              }
            }
          },
          title:{display:true, text:'Bands'}
        },
        y: { min: 0, max: 4, title:{display:true, text:'Gain (0..4)'} }
      },
      plugins: { legend: { display: false } }
    }
  });
}

function updateChartData(){
  if (!chart) return;
  chart.options.scales.x.max = Math.max(0, (nBands || gains.length) - 1);
  chart.data.datasets[0].data = makeInterpolatedCurve();
  chart.data.datasets[1].data = controlDatasetPoints();
  chart.update();
}

function linspace(a,b,n){
  if (n===1) return [a];
  const step=(b-a)/(n-1);
  return Array.from({length:n},(_,i)=> a + i*step);
}

function interp1(x, y, xq){
  // simple linear interpolation
  const n = x.length;
  const res = [];
  for (const q of xq){
    if (q <= x[0]) { res.push(y[0]); continue; }
    if (q >= x[n-1]) { res.push(y[n-1]); continue; }
    // find interval
    let j=1; while (j<n && x[j] < q) j++;
    const x0=x[j-1], x1=x[j], y0=y[j-1], y1=y[j];
    const t = (q - x0) / (x1 - x0);
    res.push(y0 + t*(y1 - y0));
  }
  return res;
}

/* ---------- Busy UI ---------- */
function setBusy(b){
  document.getElementById('processBtn').disabled = b;
  document.getElementById('fileInput').disabled = b;
  document.getElementById('progressWrap').style.display = b ? 'inline-flex' : 'none';
}

/* ---------- Init ---------- */
applyKnobs();

/* ---------- Processing ---------- */
async function process(){
  if (document.getElementById('processBtn').disabled) return;

  const controller = new AbortController();
  const timeout = setTimeout(()=>controller.abort(), 180000);
  try{
    setMsg('');
    const file = document.getElementById("fileInput").files[0];
    if (!file){ setMsg("Choose an image first."); return; }
    setBusy(true);

    const gains_csv = gains.map(v=> v.toFixed(3)).join(',');

    const fd = new FormData();
    fd.append("file", file);
    fd.append("alpha", alpha.value);
    fd.append("gamma", gamma.value);
    fd.append("sigma_perc", sigma_perc.value);
    fd.append("max_kernel", max_kernel.value);
    fd.append("band_sign", band_sign.value);
    fd.append("preserve_mean", document.getElementById('preserve_mean').checked ? "true" : "false");
    fd.append("n_controls", String(gains.length));
    fd.append("gains_csv", gains_csv);

    const r = await fetch(apiUrl('api/process'), { method: "POST", body: fd, signal: controller.signal });
    if (!r.ok){
      const text = await r.text().catch(()=>"(no details)");
      throw new Error(text);
    }
    const data = await r.json();

    // update kernels/ticks and band count for chart
    kernels = data.kernels || [];
    nBands = data.n_bands || (kernels?.length || 0);
    renderChart();
    updateChartData();

    // show images
    const origUrl = "data:image/png;base64," + data.original_b64;
    const eqUrl   = "data:image/png;base64," + data.equalized_b64;
    const modUrl  = "data:image/png;base64," + data.modulated_b64;

    document.getElementById("imgOriginal").src = origUrl;
    document.getElementById("imgEqualized").src = eqUrl;
    document.getElementById("imgModulated").src = modUrl;

    // downloads
    const dlEq = document.getElementById("downloadLinkEq");
    dlEq.href = eqUrl; dlEq.download = "equalized.png"; dlEq.style.display = "inline";
    const dlMod = document.getElementById("downloadLinkMod");
    dlMod.href = modUrl; dlMod.download = "modulated.png"; dlMod.style.display = "inline";

    // overlays (auto on after process)
    const params = data.params || {};
    const overlayText =
      `max_kernel: ${params.max_kernel}\n` +
      `sigma: ${Number(params.sigma_perc).toFixed(2)}\n` +
      `alpha: ${Number(params.alpha).toFixed(2)}\n` +
      `gamma: ${Number(params.gamma).toFixed(2)}\n` +
      `band_sign: ${params.band_sign}\n` +
      `preserve_mean: ${params.preserve_mean}\n` +
      `N: ${params.n_controls}\n` +
      `gains: ${params.gains_csv}`;

    setOverlay("Orig",  overlayText, document.getElementById("overlayOrig").checked);
    setOverlay("Eq",    overlayText, document.getElementById("overlayEq").checked);
    setOverlay("Mod",   overlayText, document.getElementById("overlayMod").checked);

    // hook toggles
    ["Orig","Eq","Mod"].forEach(kind=>{
      document.getElementById("overlay"+kind).onchange = (e)=>{
        setOverlay(kind, overlayText, e.target.checked);
      };
    });

  }catch(err){
    setMsg("Error: " + (err?.message || String(err)));
  }finally{
    clearTimeout(timeout);
    setBusy(false);
  }
}

function setOverlay(kind, text, show){
  const box = document.getElementById("overlayBox"+kind);
  box.textContent = text;
  box.style.display = show ? "block" : "none";
}
</script>

<!-- Progress row (placed at end so functions exist) -->
<div class="row" style="margin-top:8px;">
  <div id="progressWrap"><div class="spinner"></div><span id="progressText">Processing…</span></div>
</div>

</body>
</html>
